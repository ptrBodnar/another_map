<!DOCTYPE html>
<html>
<head>
	
	<title>Quick Start - Leaflet</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js" integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA==" crossorigin=""></script>
	<script src="lib/d3.v5.js"></script>


</head>
<body>



<div id="body">
	<div id="mapid" style="width: 1400px; height: 800px;"></div>
</div>

<script>


	var mapWidth = document.getElementById('body').clientWidth;

	var halfRadius = 10;

	var size = d3.scaleSqrt()
			.domain([0, 1])
			.range([0, halfRadius]);

	var map = L.map('mapid').setView([51.505, 33], 7);

	L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 18,
		attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
			'<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
		id: 'mapbox.streets'
	}).addTo(map);


	var pie = d3.pie()
			.sort(null)
			// .value(function(d) { return d.size; });
			.value(function (d) {
				return 5;
			});

	d3.csv('https://docs.google.com/spreadsheets/d/e/2PACX-1vR3ID5fcAnl8YyHHNjg5CGb73vgtYmBmmMNbOSQpYH8CUuvGqYV7e_YTuUn1eWu7jCq3BGYGmVJGU-V/pub?gid=1602640575&single=true&output=csv')
			.then(function(data) {


				mapHeight = window.innerHeight - 50;
				map.width = mapWidth;
				map.height = mapHeight;

				var long_data = [];
				data.forEach( function(row) {
					// Loop through all of the columns, and for each column
					// make a new row
					Object.keys(row).forEach( function(colname) {

						var remain = ['automaton_height', 'doors_size', 'latitude', 'light_1',
							'light_2', 'light_3', 'light_4', 'light_5', 'light_6', 'longitude',
							'line', 'mean_light', 'paydesk_height', 'station', 'station_laying_type',
							'stations_location', 'strange_name', 'tile_type', 'turnstiles_size'];

						if(remain.includes(colname)) {
							return
						}
						long_data.push({'automaton_height': +row['automaton_height'], 'doors_size': +row['doors_size'],
							'latitude': row['latitude'], 'longitude': row['longitude'], 'light_1': +row['light_1'],
							'light_2': +row['light_2'], 'light_3': +row['light_3'], 'light_4': +row['light_4'],
							'light_5': +row['light_5'], 'light_6': +row['light_6'],
							'line': row['line'], 'mean_light': +row['mean_light'].replace(',', '.'),
							'paydesk_height': +row['paydesk_height'], 'station': row['station'],
							'station_laying_type': row['station_laying_type'],
							'stations_location': row['stations_location'], 'strange_name': row['strange_name'],
							'tile_type': row['tile_type'], 'turnstiles_size': +row['turnstiles_size'],
						 'category_name': colname, 'value': row[colname]});
					});
				});


				var nested = d3.nest()
						.key(function (d) {
							return d.station
						})
						.entries(long_data);

				var projection;
//				var zoom;
//
//				var zoomTrans = {x: 0, y: 0, scale: 1};

				if (window.innerWidth > 2000) {
					projection = d3.geoMercator()
							.scale(window.innerWidth)
							.rotate([0, 0, 0])
//							.center([50.450815, 30.522588]);

//					zoom = d3.zoom()
//							.scaleExtent([4, 4])
//							.on('zoom', function () {
//
//								map.redraw(d3.event.transform);
//
//								if (d3.event.transform.k === 1) {
//									d3.select('#labels').style("display", "none")
//								}
//								if (d3.event.transform.k > 1) {
//									d3.select('#labels').style("display", "block")
//								}
//							});

				}
				else if (window.innerWidth < 2000) {
					projection = d3.geoMercator()
							.scale(window.innerWidth, 800)
							.rotate([0, 0, 0]);
//
//					projection = d3.geoAzimuthalEqualArea()
////							.scale(400)
//////							.rotate([0, 0, 0])
////							.center([50.450815, 30.522588])
//							.translate(700, 400);


//					zoom = d3.zoom()
//							.scaleExtent([6, 6])
//							.on('zoom', function () {
//
//								zoomTrans.x = d3.event.transform.x;
//								zoomTrans.y = d3.event.transform.y;
//								zoomTrans.scale = d3.event.transform.k;
//
//								map.redraw(d3.event.transform, riverForDrawId);
//
//								if (d3.event.transform.k === 1) {
//									d3.select('#labels').style("display", "none")
//								}
//								if (d3.event.transform.k > 1) {
//									d3.select('#labels').style("display", "block")
//								}
//							});
				}



				map.svg =
						d3.select('div.leaflet-pane.leaflet-overlay-pane')
								.append('svg')
								.attr("id", "flowers")
								// .attr("preserveAspectRatio", "xMinYMin meet")
								// .attr("viewBox", "0 0 960 350")
								.attr('width', 1400)
								.attr('height', 800)
								.append('g');

				var feature = map.svg.selectAll(".petal")
						.data(nested)
						.enter().append('g')
						.attr("transform", function (d) {
							console.log(d)
							return "translate(" + projection([d.values[0].longitude
										, d.values[0].latitude]) + ")";
////
//							var a = projectPoint(d.values[0].longitude
//								, d.values[0].latitude);
//							return "translate(" + Object.values(a) + ")";
//
						})
						.each(function (d, i) {
							d3.select(this).selectAll('.petal')
									.data(pie(d.values))
									.enter()
									.append("path")
//									.attr("class", function (d) {
//										var basin = d.data.river;
//										var filteredArray = riversNames.filter(function (obj) {
//											return obj.key === basin;
//										});
//										if (filteredArray.length > 0) {
//											return filteredArray[0].value + " petal myBtn"
//										} else {
//											return "petal myBtn"
//										}
//
//									})
									.attr("transform", function (d) {
										return r((d.startAngle + d.endAngle) / 2);
									})

									.attr("d", petalPath)
									.style("stroke", "#e50000")
									.style("stroke-width", "1px")
									.style('fill', '#e50000')
//									.style("fill", function (d) {
//										//якщо не кисень
//										if (d.data.key != "Кисень.розчинений.МгО2.дм3") {
//											if (d.data.size > 0.9) {
//												// return PointColorsRed(d.data.size);
//												return reds[2]
//											}
//											else {
//												// return "#49E858"
//												return green
//											}
//										}
//
//										//якщо кисень
//										if (d.data.key === "Кисень.розчинений.МгО2.дм3") {
//											if (d.data.size > 0.9) {
//												return green;
//											}
//											else {
//												// return "#49E858"
//												return reds[2]
//											}
//
//
//										}
//
//									})

//									.on("mouseover", function (d) {
//										var targetFlower = d3.select(this.parentNode);
//										targetFlower.moveToFront();
//
//										flowerhint.transition()
//												.duration(200)
//												.style("opacity", .9);
//
//										flowerhint.html(d.data.name)
//												.style("left", (d3.event.pageX) + "px")
//												.style("top", (d3.event.pageY) + "px");
//
//									})
//									.on("mouseout", function (d) {
//										flowerhint.transition()
//												.duration(200)
//												.style("opacity", 0);
//
//
//									})

									/*чому тут d повертає не той датасет? , що треба, а гемометрію?????*/
//									.on('click', function (d) {
//										var modal = document.getElementById('myModal');
//										var span = document.getElementsByClassName("close")[0];
//
//										modal.style.display = "block";
//										span.onclick = function () {
//											modal.style.display = "none";
//										};
//										window.onclick = function (event) {
//											if (event.target == modal) {
//												modal.style.display = "none";
//											}
//										};
//
//										var IdForChart = d.data.id;
//										var keyindicator = d.data.key;
//										var norm = d.data.norm;
//
//
//										drawBigFlower(IdForChart);
//										drawChart(IdForChart, keyindicator);
//
//
//									})


						});

				update()


				function update() {
					feature.attr("cx",function(d) {
						return map.latLngToLayerPoint([d.values[0].longitude, d.values[0].latitude]).x
					});
					feature.attr("cy",function(d) {
						return map.latLngToLayerPoint([d.values[0].longitude, d.values[0].latitude]).y
					});
//					feature.attr("r",function(d) { return d.properties.count/1400*Math.pow(2,map.getZoom())})
				}
				map.on("viewreset", update);

			});

	var flowefsize = 0.08;

	function petalPath(d) {
		var angle = (d.endAngle - d.startAngle) / 3,
				s = polarToCartesian(-angle, halfRadius),
				e = polarToCartesian(angle, halfRadius),
		// r = size(d.data.size),

				r = size(flowefsize),

				m = {x: halfRadius + r, y: 0},
				c1 = {x: halfRadius + r / 2, y: s.y},
				c2 = {x: halfRadius + r / 2, y: e.y};
		return "M0,0Q" + Math.round(c1.x) + "," + Math.round(c1.y * 2) + " " + Math.round(m.x + r) + "," + Math.round(m.y) + "Q" + Math.round(c2.x) + "," + Math.round(c2.y * 2) + " " + Math.round(0) + "," + Math.round(0) + "Z";
	};

	function r(angle) {
		return "rotate(" + (angle / Math.PI * 180) + ")";
	}

	function polarToCartesian(angle, radius) {
		return {
			x: Math.cos(angle) * radius,
			y: Math.sin(angle) * radius
		};
	}


	function projectPoint(x, y) {
		// Returns the map layer point that corresponds to the given geographical coordinates
		var point = map.latLngToLayerPoint(new L.LatLng(y, x));
		return point
//		this.stream.point(point.x, point.y);
	}


</script>



</body>
</html>
